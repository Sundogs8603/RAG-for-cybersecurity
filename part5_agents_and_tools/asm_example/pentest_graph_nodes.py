# LangGraph Example: Pentesting Workflow Nodes
#
# This script defines the nodes for our pentesting workflow using LangGraph.
# It includes the necessary nodes to discover subdomains, scan for open ports,
# and scan for vulnerabilities.
#
# Instructor: Omar Santos @santosomar


import json
from typing import List
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.output_parsers.json import JsonOutputParser
from pentest_graph_state import AttackSurfaceState

# --- Placeholder Tools ---
def run_subfinder(domain: str) -> List[str]:
    """Simulates running subfinder to discover subdomains. 
    Subfinder is a tool that discovers subdomains of a domain.
    We are using a placeholder tool to simulate the tool.
    """
    print(f"--- TOOL: Running subfinder on {domain} ---")
    return [f"api.{domain}", f"blog.{domain}", f"test.{domain}"]

def run_nmap(host: str) -> List[int]:
    """Simulates running nmap to find open ports."""
    print(f"--- TOOL: Running nmap on {host} ---")
    if "api" in host:
        return [80, 443, 8080]
    else:
        return [80, 443]

def run_nuclei(host: str, ports: List[int]) -> List[dict]:
    """Simulates running nuclei to find vulnerabilities.
    Nuclei is a tool that scans for vulnerabilities in a given host and port.
    We are using a placeholder tool to simulate the tool.
    """
    print(f"--- TOOL: Running nuclei on {host}:{ports} ---")
    if host.startswith("api") and 8080 in ports:
        return [{
            "template-id": "log4j-detect",
            "name": "Log4Shell Detection",
            "severity": "critical",
            "host": host,
            "matched-at": f"https://{host}:8080"
        }]
    return []

# --- Graph Nodes ---
def reconnaissance_step(state: AttackSurfaceState) -> dict:
    """Node for discovering subdomains and open ports."""
    domain = state["target_domain"]
    log = state.get("workflow_log", [])
    
    subdomains = run_subfinder(domain)
    all_hosts = [domain] + subdomains
    
    open_ports = {}
    for host in all_hosts:
        ports = run_nmap(host)
        if ports:
            open_ports[host] = ports
            
    return {
        "subdomains": subdomains,
        "open_ports": open_ports,
        "workflow_log": log + ["Completed Reconnaissance"]
    }

def vulnerability_scan_step(state: AttackSurfaceState) -> dict:
    """Node for scanning discovered assets for vulnerabilities."""
    hosts_with_ports = state["open_ports"]
    log = state.get("workflow_log", [])
    all_vulnerabilities = []
    
    for host, ports in hosts_with_ports.items():
        vulnerabilities = run_nuclei(host, ports)
        all_vulnerabilities.extend(vulnerabilities)
        
    return {
        "vulnerabilities": all_vulnerabilities,
        "workflow_log": log + ["Completed Vulnerability Scanning"]
    }

def analysis_step(state: AttackSurfaceState) -> dict:
    """Node for analyzing scan results with an LLM."""
    vulnerabilities = state["vulnerabilities"]
    log = state.get("workflow_log", [])
    
    if not vulnerabilities:
        return {
            "analysis_result": "No critical vulnerabilities found.",
            "is_exploitable": False,
            "workflow_log": log + ["Analysis: No findings."]
        }
        
    prompt = ChatPromptTemplate.from_messages([
        ("system", "You are a senior penetration tester. Analyze the following Nuclei scan results. "
                   "Determine if any of them represent a high-probability, exploitable vulnerability. "
                   "Respond in JSON format with two keys: 'analysis' and 'is_exploitable'."),
        ("human", "Here are the scan results:\n\n{scan_results}")
    ])
    
    llm = ChatOpenAI(model="gpt-5", temperature=0.1)
    parser = JsonOutputParser()
    
    chain = prompt | llm | parser
    
    response = chain.invoke({"scan_results": json.dumps(vulnerabilities, indent=2)})
    
    return {
        "analysis_result": response.get("analysis"),
        "is_exploitable": response.get("is_exploitable", False),
        "workflow_log": log + ["Analysis Completed"]
    }

def report_step(state: AttackSurfaceState) -> dict:
    """Node for compiling the final report."""
    log = state.get("workflow_log", [])
    report_parts = [
        f"# Attack Surface Report for: {state['target_domain']}\n",
        f"## Discovered Subdomains:\n- " + "\n- ".join(state['subdomains']),
        "\n## Open Ports Discovered:",
    ]
    for host, ports in state["open_ports"].items():
        report_parts.append(f"- {host}: {ports}")
        
    report_parts.append("\n## Vulnerability Findings:")
    if state["vulnerabilities"]:
        for vuln in state["vulnerabilities"]:
            report_parts.append(f"- **[{vuln['severity'].upper()}]** {vuln['name']} on {vuln['host']}")
    else:
        report_parts.append("- No vulnerabilities found.")
        
    report_parts.append(f"\n## Analysis:\n{state['analysis_result']}")
    
    return {"report": "\n".join(report_parts), "workflow_log": log + ["Report Generated"]}
