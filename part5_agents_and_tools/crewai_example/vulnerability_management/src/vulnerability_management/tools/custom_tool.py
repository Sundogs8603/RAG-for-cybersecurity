from crewai.tools import BaseTool
from typing import Type, List
from pydantic import BaseModel, Field
import subprocess
import json
import socket
import requests
from datetime import datetime


class NmapScanInput(BaseModel):
    """Input schema for NmapScanTool."""
    target: str = Field(..., description="Target IP address or hostname to scan")
    scan_type: str = Field(default="basic", description="Type of scan: basic, aggressive, stealth, or service")
    ports: str = Field(default="1-1000", description="Port range to scan (e.g., '1-1000', '80,443,22')")


class NmapScanTool(BaseTool):
    name: str = "nmap_vulnerability_scanner"
    description: str = (
        "Perform network vulnerability scanning using Nmap. This tool can identify open ports, "
        "services, and potential security vulnerabilities on target systems. Use this for initial "
        "network reconnaissance and service discovery."
    )
    args_schema: Type[BaseModel] = NmapScanInput

    def _run(self, target: str, scan_type: str = "basic", ports: str = "1-1000") -> str:
        """Execute Nmap scan based on specified parameters."""
        try:
            # Validate target is not obviously malicious
            if not target or target.strip() == "":
                return "Error: No target specified"
            
            # Build nmap command based on scan type
            if scan_type == "basic":
                cmd = ["nmap", "-sS", "-p", ports, target]
            elif scan_type == "aggressive":
                cmd = ["nmap", "-A", "-p", ports, target]
            elif scan_type == "stealth":
                cmd = ["nmap", "-sS", "-f", "-p", ports, target]
            elif scan_type == "service":
                cmd = ["nmap", "-sV", "-sC", "-p", ports, target]
            else:
                cmd = ["nmap", "-sS", "-p", ports, target]
            
            # Execute the scan (with timeout)
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
            
            if result.returncode == 0:
                return f"Nmap scan results for {target}:\n{result.stdout}"
            else:
                return f"Nmap scan failed for {target}: {result.stderr}"
                
        except subprocess.TimeoutExpired:
            return f"Nmap scan timed out for target {target}"
        except FileNotFoundError:
            return "Error: Nmap is not installed or not found in PATH. Please install nmap first."
        except Exception as e:
            return f"Error running nmap scan: {str(e)}"


class CVELookupInput(BaseModel):
    """Input schema for CVELookupTool."""
    cve_id: str = Field(..., description="CVE identifier (e.g., CVE-2021-44228)")


class CVELookupTool(BaseTool):
    name: str = "cve_vulnerability_lookup"
    description: str = (
        "Look up detailed information about specific CVE vulnerabilities including severity scores, "
        "descriptions, and exploitation details. Use this to get comprehensive information about "
        "known vulnerabilities identified during scanning."
    )
    args_schema: Type[BaseModel] = CVELookupInput

    def _run(self, cve_id: str) -> str:
        """Look up CVE information from public databases."""
        try:
            if not cve_id or not cve_id.startswith('CVE-'):
                return "Error: Invalid CVE ID format. Expected format: CVE-YYYY-NNNN"
            
            # Use the NIST NVD API to get CVE information
            api_url = f"https://services.nvd.nist.gov/rest/json/cves/2.0?cveId={cve_id}"
            
            response = requests.get(api_url, timeout=10)
            
            if response.status_code == 200:
                data = response.json()
                
                if 'vulnerabilities' in data and len(data['vulnerabilities']) > 0:
                    vuln = data['vulnerabilities'][0]['cve']
                    
                    # Extract key information
                    result = {
                        'cve_id': vuln['id'],
                        'published': vuln.get('published', 'N/A'),
                        'last_modified': vuln.get('lastModified', 'N/A'),
                        'description': vuln['descriptions'][0]['value'] if vuln.get('descriptions') else 'N/A',
                        'cvss_v3': 'N/A',
                        'severity': 'N/A'
                    }
                    
                    # Extract CVSS information if available
                    if 'metrics' in vuln:
                        if 'cvssMetricV31' in vuln['metrics']:
                            cvss = vuln['metrics']['cvssMetricV31'][0]['cvssData']
                            result['cvss_v3'] = cvss['baseScore']
                            result['severity'] = cvss['baseSeverity']
                        elif 'cvssMetricV30' in vuln['metrics']:
                            cvss = vuln['metrics']['cvssMetricV30'][0]['cvssData']
                            result['cvss_v3'] = cvss['baseScore']
                            result['severity'] = cvss['baseSeverity']
                    
                    return json.dumps(result, indent=2)
                else:
                    return f"No information found for CVE ID: {cve_id}"
            else:
                return f"Failed to retrieve CVE information. Status code: {response.status_code}"
                
        except requests.exceptions.Timeout:
            return "Timeout while retrieving CVE information"
        except requests.exceptions.RequestException as e:
            return f"Error retrieving CVE information: {str(e)}"
        except Exception as e:
            return f"Error looking up CVE: {str(e)}"


class PortScanInput(BaseModel):
    """Input schema for PortScanTool."""
    target: str = Field(..., description="Target IP address or hostname")
    ports: List[int] = Field(default=[22, 80, 443, 3389], description="List of ports to scan")
    timeout: int = Field(default=3, description="Connection timeout in seconds")


class PortScanTool(BaseTool):
    name: str = "basic_port_scanner"
    description: str = (
        "Perform basic port scanning to identify open ports on target systems. This is useful "
        "for initial reconnaissance and service discovery. Lighter weight than Nmap for quick checks."
    )
    args_schema: Type[BaseModel] = PortScanInput

    def _run(self, target: str, ports: List[int] = None, timeout: int = 3) -> str:
        """Perform basic port scan using socket connections."""
        if ports is None:
            ports = [22, 80, 443, 3389, 21, 25, 53, 110, 143, 993, 995]
        
        open_ports = []
        closed_ports = []
        
        try:
            # Resolve hostname to IP
            target_ip = socket.gethostbyname(target)
            
            for port in ports:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(timeout)
                
                result = sock.connect_ex((target_ip, port))
                
                if result == 0:
                    open_ports.append(port)
                else:
                    closed_ports.append(port)
                
                sock.close()
            
            scan_results = {
                'target': target,
                'target_ip': target_ip,
                'scan_time': datetime.now().isoformat(),
                'open_ports': open_ports,
                'closed_ports': closed_ports,
                'total_scanned': len(ports)
            }
            
            return json.dumps(scan_results, indent=2)
            
        except socket.gaierror:
            return f"Error: Could not resolve hostname {target}"
        except Exception as e:
            return f"Error during port scan: {str(e)}"
